## 虚拟内存

### 为什么引入

物理内存的缺点是

+ **地址空间不隔离**：不同程序可能交叉访问其他程序的内存空间，且安全性得不到保障

+ **使用效率低**：若多个程序需求内存超过物理内存大小，没有比较好的策略保证他们的使用

+ **程序运行地址不能确定**：程序每次运行时，需要在内存中分配足够大的空闲区域，但这个空闲区域的位置是不能确定的

因此我们引入了 **虚拟内存**，即每个程序有自己独立的进程地址空间，且里面的地址都是虚拟地址。显然，这里的虚拟地址是和物理地址是一个一对一对应的关系。因此，虚拟空间里连续的一段内存在物理内存中可能是离散的。

当然，要注意的是，这里的物理地址可能有部分是对应在 **磁盘** 上。

### 虚拟内存的划分

Linux 虚拟内存可以被划分成 **用户空间内存 (User Space)** 和 **内核空间内存 (Kernel Space)**。一般情况下，用户进程只能访问对应着用户空间内存的虚拟地址，而不能访问到对应内核空间内存的地址。除了用户进程进行系统调用 syscall 的时候才能访问到内核空间。

对于 32 位系统，最大寻址范围为 `4G`，也就是说整个虚拟地址的大小为 `4G`。Linux 一般把它分为两个部分，其中 `0x00000000` 到 `0xBFFFFFFF` （`0-3G`） 为用户空间地址，而 `0xC0000000` 到 `0xFFFFFFFF` （`3-4G`）是内核空间地址。而在 64 位系统当中，Linux 实际使用的虚拟空间地址为 48 位，在空间地址中，第 47 位与 48 ~ 63 位相同，若这些位为 `0` 表示用户空间，否则表示内核空间。

每个进程的用户空间完全独立，互不干扰。但所有的进程都共享同一个内核空间。

### 虚拟内存和物理内存的映射方案

主要应用的是 **分段** 和 **分页** 两种方法。

+ **分段 (Segmentation)**

将两块 **大小相同** 的虚拟内存地址和物理内存地址建立映射。这样解决了地址隔离和地址重定位的问题，但这样的映射没办法解决效率问题，内存不足时依然要交换到磁盘。

+ **分页 (Page)**

将内存地址空间分为若干个很小的固定大小的页。Linux 中的页大小一般为 `4KB`。同样地，也把进程的地址空间按页分割，再进行映射。把 **常用** 的数据和代码页装装载到内存中，把 **不常用** 的装载到磁盘中。它的意义在于，在 **连续物理内存** 不够的时候，我们可以通过分页很好的利用那些离散的内存，甚至多个进程可能 **共用** 一部分物理内存。如果程序需要某几页在磁盘中的内存，Linux 内核会产生一个缺页异常，然后异常管理程序会将其从磁盘读入到内存中。

分页机制的实现依赖于 **MMU (Memory Management Unit)** 这样一个硬件，负责从虚拟页找到物理页。

### 参考资料

https://www.jianshu.com/p/a0993c07f660

---

## 内存管理单元 MMU

MMU 是 CPU 中负责内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制等。

MMU 的工作机制是，CPU 发出虚拟地址，然后 MMU 通过 **页表 (Page Table)** 查询这个虚拟地址对应的真实地址是什么，然后访问外面的内存条。这个页表储存在 MMU 里的寄存器中。

### 单级页表

假设每一页大小为 `4KB`，且页表只有一级，那么它长这样。

![img](https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytI9k2b7fIYiasftN1IXtSDMbjraPgXDXs23OC7tSCJKlrq6Bexv2dX2WrYJ8BZnY1pMxWNetRYKicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

当虚拟地址为 `0` 时，MMU 会查询第 0 行，发现没有命中，无论以何种方式访问（R 写，W 读，X 执行）会发出 `page fault`。而访问 `4KB` 时（即第一行，因为每一页 `4KB`），则第一行已经命中，那么 CPU 会访问对应的物理地址，如果请求的操作不满足其记录的权限，会重新激发 `page fault`。当然，如果不满足对应的 User / Kernel 权限，同样也会引发 `page fault`。

如果寻址空间为 `4 GB`，那么这个表的大小则为 `4 MB`。每一个虚拟内存都可以用地址的高 20 位来当行数访问（后 12 位为 `4 * (2^10) = 4KB` 的页内偏移）。

### 多级页表

单级页表的话，每个进程都需要 `4MB` 的页表。而如果我们考虑将地址的前 10 位当做一级页表的索引，中间 10 位当二级页表的索引。比如我们要访问虚拟地址 `16`，则分级后我们有

```
0000 0000 00 | 0000 0000 00 | 0000 0001 0000
```

则我们先会在一级页表找 `0` 这个地址，如果命中了，如图中是 `2MB`，则 MMU 会找到 `2MB` 这个位置的二级页表，然后根据上面第二段的偏移量 `0`，我们看到了物理地址为 `1GB`。因此我们根据第三段的偏移量 `16`，最终访问的是 `1GB + 16` 这个真实地址。

![img](https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytI9k2b7fIYiasftN1IXtSDMqOdicAGMe7kK2gDvwvxDLNUaBiczq9ugqw8ACBJM8kicmlU9bXAzAYz1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

用多级页表的好处是，如果第一级页表没有命中，那么就不需要保存相应的二级页表了。可以节省对应的空间。

---

## 内存分区

Linux 会对内存节点进行划分，通常一个节点分为 `DMA` ， `Normal` 和 `High Memory` 分区。

+ **DMA 内存区** ： 直接内存访问分区，通常为物理内存的其实 `16M`。主要是供外设使用，外设和内存直接访问数据，无需 CPU 参与

+ **Normal 内存区** ： `16M` 到 `896M`，与物理内存线性映射。

+ **High Memory 内存区** ： `896M` 后的内存区

除了 `High Memory` 内存区，剩下的都是 `Low Memory` 内存区。

前面已经提到，Linux 的 Kernel 虚拟内存空间为 `3-4G`，因为虚拟内存和物理内存是映射关系，那么如果系统的物理内存超过 `1G`，则任何时间，肯定有一部分物理内存没有办法访问到。另外，Kernel 除了访问物理内存外，还需要访问很多 IO 设备。在现在的计算机体系结构下，这些 IO 设备的资源（比如寄存器，片上内存等）一般都是通过 MMIO 的方式映射到物理内存地址空间来访问的，就是说 Kernel 的 `1G` 地址空间除了映射内存，还要考虑到映射这些 IO 资源。

因此超出 `896M` 的物理内存（被直接映射了）和这些 IO 资源，我们要通过动态映射在 Kernel 中通过 `128M` 地址来访问。

### 参考资料

https://www.cnblogs.com/kerrycode/p/5200843.html

---

## 内存分配算法

### Buddy 算法

`DMA` ， `Normal` 和 `High Memory` 三个分区都是采用 Buddy 算法管理。即把空闲的页数进行二进制拆分，以幂次作为索引管理这些叶框的碎片。

例如，假设现在 `ZONE_NORMAL` 中有 `16` 页内存，现在有人申请一页内存，那么剩下的 `15` 页会被拆分为 `8 + 4 + 2 + 1`，并被放到对应的索引下。若请求的内存太大，没有这么大的内存块，则会返回错误。

页框块在释放时，会主动将两个连续的页框块合并为一个较大的页框块。

![img](https://pic3.zhimg.com/80/v2-90378f7a3b2bbaa6aad693d73544b862_720w.jpg)

### CMA 算法

Buddy 算法会避免外部碎片的问题（系统无法分配给用户使用的内存），但长时间分配释放后，可能内存会没有大块的连续内存，虽然这不会影响使用（虚拟内存可以将离散的内存映射到里连续的地址），但内核态就无法获取大块连续的内存了（许多内核态应用是对连续内存有需求的）。

CMA 为了解决这个问题，把一块连续区域标记为 CMA 区域，在内存申请的时候只给 moveable 的程序使用。当大片连续内存的请求出现时，我们把这个区域内所有的内存移动到非 CMA 区域，更改程序对应的页表，然后再把腾出来的空间分配出去。

CMA 通常为 DMA 设备服务，且 CMA 区域通常被分配在高端内存。

### Slab 算法

在 Buddy 算法中，最小的内存分配单位为 `4KB`，也就是一页，但是很多时候申请的大小只有几十个字节，这样分配出去会造成很大的浪费，也就是所谓的内部碎片（分配出去但用户不能使用的）。

那么 Slab 算法是为了解决这个问题的，它对从 Buddy 拿到的内存进行二次管理，以更小的单位进行分配和回收（不是释放）。并且它会让频繁使用的对象尽量分配在同一块内存区间，并保留基本的数据结构。

例如，如果某个结构被频繁使用（例如 `TCPv6`，`UDPv6`），Kernel 就可以针对这个结构建立一个 Slab 分区，每一个 Slab 分区会从 Buddy 拿到一页或者多页内存，并把这些内存等分为这个结构大小的内存。当每次有这种结构的请求时，就分配一小块内存出去建立结构。

### 参考资料

https://www.jianshu.com/p/271c316b53ef

---

## 内存分配函数

### `malloc`

负责分配用户空间内存。

### `kmalloc`

负责分配内核空间内存，用于申请 **较小的、连续的物理内存**，以字节为单位。由于内存时线性映射，因此使用 `kmalloc` 分配内存时十分高效的。内存只有在 DMA 访问的时候才需要物理上连续。

### `vmalloc`

负责分配内核空间内存，用于申请 **较大** 的内存空间，分配速度较慢，因为对应的物理空间可能不是连续的。

---

## 内存回收

Linux 中页的回收主要通过两种方式触发：

+ 由内存严重不足 (Out of Memory) 触发

+ 由后台进程 `kswapd` 触发，该进程周期性运行，一旦空闲内存小于阈值

### 哪些页框可以回收

+ 属于内核的大部分页框不能被回收，比如内核栈、内核代码段、内核数据段和大部分内存使用的页框

+ 进程使用的页框是可以回收的，比如进程代码段、进程数据段、进程堆栈、进程访问文件时映射的文件页、进程间共享使用的页

### 回收页的操作和分类

Linux 进程的页分为如下几种：

+ **文件页 (File-backed Pages)** ： 有文件背景的页面，如代码段，可以直接和硬盘对应的文件交换

+ **匿名页 (Anonymous Pages)** ： 如进程堆、栈、数据段使用的页、匿名 mmap 共享内存使用的页、shmem 共享内存使用的页，如果交换的话，需要交换到虚拟内存 (swapfile) 或者 Linux 的 `swap` 分区

+ 被锁在内存中禁止被交换出的页

回收操作主要有两种：

+ 直接将一些页释放

+ 将页回写保存到磁盘里（磁盘区或 `swap` 分区），然后再释放

### 参考资料

https://www.jianshu.com/p/7ab51b8a6368