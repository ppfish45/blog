## 虚拟内存

### 为什么引入

物理内存的缺点是

+ **地址空间不隔离**：不同程序可能交叉访问其他程序的内存空间，且安全性得不到保障

+ **使用效率低**：若多个程序需求内存超过物理内存大小，没有比较好的策略保证他们的使用

+ **程序运行地址不能确定**：程序每次运行时，需要在内存中分配足够大的空闲区域，但这个空闲区域的位置是不能确定的

因此我们引入了 **虚拟内存**，即每个程序有自己独立的进程地址空间，且里面的地址都是虚拟地址。显然，这里的虚拟地址是和物理地址是一个一对一对应的关系。因此，虚拟空间里连续的一段内存在物理内存中可能是离散的。

当然，要注意的是，这里的物理地址可能有部分是对应在 **磁盘** 上。

### 虚拟内存的划分

Linux 虚拟内存可以被划分成 **用户空间内存 (User Space)** 和 **内核空间内存 (Kernel Space)**。一般情况下，用户进程只能访问对应着用户空间内存的虚拟地址，而不能访问到对应内核空间内存的地址。除了用户进程进行系统调用 syscall 的时候才能访问到内核空间。

对于 32 位系统，最大寻址范围为 `4G`，也就是说整个虚拟地址的大小为 `4G`。Linux 一般把它分为两个部分，其中 `0x00000000` 到 `0xBFFFFFFF` （`0-3G`） 为用户空间地址，而 `0xC0000000` 到 `0xFFFFFFFF` （`3-4G`）是内核空间地址。而在 64 位系统当中，Linux 实际使用的虚拟空间地址为 48 位，在空间地址中，第 47 位与 48 ~ 63 位相同，若这些位为 `0` 表示用户空间，否则表示内核空间。

每个进程的用户空间完全独立，互不干扰。但所有的进程都共享同一个内核空间。

### 虚拟内存和物理内存的映射方案

主要应用的是 **分段** 和 **分页** 两种方法。

+ **分段 (Segmentation)**

将两块 **大小相同** 的虚拟内存地址和物理内存地址建立映射。这样解决了地址隔离和地址重定位的问题，但这样的映射没办法解决效率问题，内存不足时依然要交换到磁盘。

+ **分页 (Page)**

将内存地址空间分为若干个很小的固定大小的页。Linux 中的页大小一般为 `4KB`。同样地，也把进程的地址空间按页分割，再进行映射。把 **常用** 的数据和代码页装装载到内存中，把 **不常用** 的装载到磁盘中。它的意义在于，在 **连续物理内存** 不够的时候，我们可以通过分页很好的利用那些离散的内存，甚至多个进程可能 **共用** 一部分物理内存。如果程序需要某几页在磁盘中的内存，Linux 内核会产生一个缺页异常，然后异常管理程序会将其从磁盘读入到内存中。

分页机制的实现依赖于 **MMU (Memory Management Unit)** 这样一个硬件，负责从虚拟页找到物理页。

### 参考资料

https://www.jianshu.com/p/a0993c07f660

---

## 内存管理单元 MMU

MMU 是 CPU 中负责内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制等。

MMU 的工作机制是，CPU 发出虚拟地址，然后 MMU 通过 **页表 (Page Table)** 查询这个虚拟地址对应的真实地址是什么，然后访问外面的内存条。这个页表储存在 MMU 里的寄存器中。

### 单级页表

假设每一页大小为 `4KB`，且页表只有一级，那么它长这样。

![img](https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytI9k2b7fIYiasftN1IXtSDMbjraPgXDXs23OC7tSCJKlrq6Bexv2dX2WrYJ8BZnY1pMxWNetRYKicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

当虚拟地址为 `0` 时，MMU 会查询第 0 行，发现没有命中，无论以何种方式访问（R 写，W 读，X 执行）会发出 `page fault`。而访问 `4KB` 时（即第一行，因为每一页 `4KB`），则第一行已经命中，那么 CPU 会访问对应的物理地址，如果请求的操作不满足其记录的权限，会重新激发 `page fault`。当然，如果不满足对应的 User / Kernel 权限，同样也会引发 `page fault`。

如果寻址空间为 `4 GB`，那么这个表的大小则为 `4 MB`。每一个虚拟内存都可以用地址的高 20 位来当行数访问（后 12 位为 `4 * (2^10) = 4KB` 的页内偏移）。

### 多级页表

单级页表的话，每个进程都需要 `4MB` 的页表。而如果我们考虑将地址的前 10 位当做一级页表的索引，中间 10 位当二级页表的索引。比如我们要访问虚拟地址 `16`，则分级后我们有

```
0000 0000 00 | 0000 0000 00 | 0000 0001 0000
```

则我们先会在一级页表找 `0` 这个地址，如果命中了，如图中是 `2MB`，则 MMU 会找到 `2MB` 这个位置的二级页表，然后根据上面第二段的偏移量 `0`，我们看到了物理地址为 `1GB`。因此我们根据第三段的偏移量 `16`，最终访问的是 `1GB + 16` 这个真实地址。

![img](https://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytI9k2b7fIYiasftN1IXtSDMqOdicAGMe7kK2gDvwvxDLNUaBiczq9ugqw8ACBJM8kicmlU9bXAzAYz1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

用多级页表的好处是，如果第一级页表没有命中，那么就不需要保存相应的二级页表了。可以节省对应的空间。

---

## 内存分区

Linux 会对内存节点进行划分，通常一个节点分为 `DMA` ， `Normal` 和 `High Memory` 分区。

+ **DMA 内存区** ： 直接内存访问分区，通常为物理内存的其实 `16M`。主要是供外设使用，外设和内存直接访问数据，无需 CPU 参与

+ **Normal 内存区** ： `16M` 到 `896M`，与物理内存线性映射。

+ **High Memory 内存区** ： `896M` 后的内存区

除了 `High Memory` 内存区，剩下的都是 `Low Memory` 内存区。

前面已经提到，Linux 的 Kernel 虚拟内存空间为 `3-4G`，因为虚拟内存和物理内存是映射关系，那么如果系统的物理内存超过 `1G`，则任何时间，肯定有一部分物理内存没有办法访问到。另外，Kernel 除了访问物理内存外，还需要访问很多 IO 设备。在现在的计算机体系结构下，这些 IO 设备的资源（比如寄存器，片上内存等）一般都是通过 MMIO 的方式映射到物理内存地址空间来访问的，就是说 Kernel 的 `1G` 地址空间除了映射内存，还要考虑到映射这些 IO 资源。

因此超出 `896M` 的物理内存（被直接映射了）和这些 IO 资源，我们要通过动态映射在 Kernel 中通过 `128M` 地址来访问。

### 参考资料

https://www.cnblogs.com/kerrycode/p/5200843.html

---

## 内存分配算法

### Buddy 算法

`DMA` ， `Normal` 和 `High Memory` 三个分区都是采用 Buddy 算法管理。即把空闲的页数进行二进制拆分，以幂次作为索引管理这些叶框的碎片。

例如，假设现在 `ZONE_NORMAL` 中有 `16` 页内存，现在有人申请一页内存，那么剩下的 `15` 页会被拆分为 `8 + 4 + 2 + 1`，并被放到对应的索引下。若请求的内存太大，没有这么大的内存块，则会返回错误。

页框块在释放时，会主动将两个连续的页框块合并为一个较大的页框块。

![img](https://pic3.zhimg.com/80/v2-90378f7a3b2bbaa6aad693d73544b862_720w.jpg)

### CMA 算法

Buddy 算法会避免外部碎片的问题（系统无法分配给用户使用的内存），但长时间分配释放后，可能内存会没有大块的连续内存，虽然这不会影响使用（虚拟内存可以将离散的内存映射到里连续的地址），但内核态就无法获取大块连续的内存了（许多内核态应用是对连续内存有需求的）。

CMA 为了解决这个问题，把一块连续区域标记为 CMA 区域，在内存申请的时候只给 moveable 的程序使用。当大片连续内存的请求出现时，我们把这个区域内所有的内存移动到非 CMA 区域，更改程序对应的页表，然后再把腾出来的空间分配出去。

CMA 通常为 DMA 设备服务，且 CMA 区域通常被分配在高端内存。

### Slab 算法

在 Buddy 算法中，最小的内存分配单位为 `4KB`，也就是一页，但是很多时候申请的大小只有几十个字节，这样分配出去会造成很大的浪费，也就是所谓的内部碎片（分配出去但用户不能使用的）。

那么 Slab 算法是为了解决这个问题的，它对从 Buddy 拿到的内存进行二次管理，以更小的单位进行分配和回收（不是释放）。并且它会让频繁使用的对象尽量分配在同一块内存区间，并保留基本的数据结构。

例如，如果某个结构被频繁使用（例如 `TCPv6`，`UDPv6`），Kernel 就可以针对这个结构建立一个 Slab 分区，每一个 Slab 分区会从 Buddy 拿到一页或者多页内存，并把这些内存等分为这个结构大小的内存。当每次有这种结构的请求时，就分配一小块内存出去建立结构。

### 参考资料

https://www.jianshu.com/p/271c316b53ef

---

## 内存分配函数

### `malloc`

负责分配用户空间内存。

### `kmalloc`

负责分配内核空间内存，用于申请 **较小的、连续的物理内存**，以字节为单位。由于内存时线性映射，因此使用 `kmalloc` 分配内存时十分高效的。内存只有在 DMA 访问的时候才需要物理上连续。

### `vmalloc`

负责分配内核空间内存，用于申请 **较大** 的内存空间，分配速度较慢，因为对应的物理空间可能不是连续的。

---

## 内存回收

Linux 中页的回收主要通过两种方式触发：

+ 由内存严重不足 (Out of Memory) 触发

+ 由后台进程 `kswapd` 触发，该进程周期性运行，一旦空闲内存小于阈值

### 哪些页框可以回收

+ 属于内核的大部分页框不能被回收，比如内核栈、内核代码段、内核数据段和大部分内存使用的页框，因为我们要保证系统的正常运行。

+ 进程使用的页框是可以回收的，比如进程代码段、进程数据段、进程堆栈、进程访问文件时映射的文件页、进程间共享使用的页。因为这些进程使用的页是通过 `page fault` 分配的。

### 回收页的操作和分类

Linux 进程的页分为如下几种：

+ **文件页 (File-backed Pages)** ： 有文件背景的页面，如代码段，可以直接和某个文件直接对应

+ **匿名页 (Anonymous Pages)** ： 如进程堆、栈、数据段使用的页、匿名 mmap 共享内存使用的页、shmem 共享内存使用的页，如果交换的话，需要交换到虚拟内存 (swapfile) 或者 Linux 的 `swap` 分区

+ 被锁在内存中禁止被交换出的页

回收操作主要有两种：

+ 直接将一些页释放

+ 将页回写保存到磁盘里（磁盘区或 `swap` 分区），然后再释放

### LRU 链表回收流程

LRU 链表中的页包括：可以存放到 `swap` 分区的匿名区、映射了文件的文件页、以及被锁的禁止换出的内存页。可以来说，除了内核使用的页框，都会被加入到 LRU 链表中。

而每一个 ZONE 都有一套 LRU 链表，他们包括：

+ `LRU_INACTIVE_ANON` ： 非活动匿名页 LRU 链表（`swap`）

+ `LRU_ACTIVE_ANON` ： 活动匿名页 LRU 链表（`swap`）

+ `LRU_INACTIVE_FILE` ： 非活动文件页 LRU 链表（磁盘）

+ `LRU_ACTIVE_FILE` ： 活动文件页 LRU 链表（磁盘）

+ `LRU_UNEVICTABLE` ： 所有禁止换出的页的描述符

加入到 `ACTIVE` 链表上的页其 `page->flags` 上都要设置 `PG_active` 标志。凡是设置了 `PG_unevictable` 标志的都要挂载 `LRU_UNEVICTABLE` 链表上。没有设置 `PG_active / PG_unevictable` 标志的都处于 `INACTIVE` 状态。处于相关状态的页面通过 `page->lru` 链接到对应的链表上。

当某个页被访问后，提高该页面的活跃度。提高活跃度的方法是：或者对 `page->flags` 设置 `PG_referenced` 标志，或者对 `page->flags` 设置 `PG_active` （同时该物理页面从 `INACTIVE` 链表上转移到 `ACTIVE` 链表上). 有 `PG_referenced` 和 `PG_active` 标志，可以得到页面的状态，该活跃度由低到高依次为：`00 -> 01 -> 10 -> 11`

![img](http://3.bp.blogspot.com/-CF6t45amFb0/UTcVFwSa7SI/AAAAAAAAB18/81JGETxBHcs/s320/image002-775214.png)

我们来细数一下图中的转移：

+ **1)** 当 `INACTIVE` 链表上的页数不够的时候，会调用 `shrink_active_list`，该函数会将 `ACTIVE` 链表上的页移动到 `INACTIVE` 链表上。对应于上图标号为 1 的转移

+ **2)** `make_page_accessed()` 当通过 `read()` 系统调用或者读已经在 cache 中的页面时，会提高页面的活跃度。对应标号 2 的转移

`shrink_page_list->page_check_references()` 用来在腾出链表空间时，进行状态转移

+ **3-a)** 如果是匿名页，并且最近被访问过，对应 3-a 的转移。即 `INACTIVE + PG_referenced` -> `ACTIVE`，`inactive` -> `active`。 ( `01` -> `10` 或者 `00` -> `10` )

+ **3-b)** 如果是已经映射的文件页，最近被访问过，如果 `PG_referenced` 置位或者被两个进程最近访问过，对应于 3-b 的转移（`01` -> `11`）。

+ **3-c)** 如果是已经映射的文件页，最近被访问过, 并且该 page cache 中的内容是可执行的（例如，用户进程的代码段），则 `INACTIVE` -> `ACTIVE + PG_referenced`。（`00` -> `11`，`01` -> `11`）

+ **3-d)** 如果是已经映射的文件页，最近被访问过, 则设置 `PG_referenced` 标志，仍旧保留 `INACTIVE` 状态，不进行回收。（ `00` -> `01`，`01` -> `01` ）

+ **3-e)** 除了以上情况，均进行回收。即：最近没有被访问过的匿名页和文件页。

`shrink_page_list->page_check_references()` 的返回值有下列几个

+ `PAGEREF_RECLAIM` 进行回收

+ `PAGEREF_RECLAIM_CLEAN` 若该页是干净的(clean)，则进行回收

+ `PAGEREF_KEEP` 仍然保持在 `INACTIVE` 链上，不进行回收

+ `PAGEREF_ACTIVATE` 不进行回收，并将该页转移到 `ACTIVE` 链上

![img](http://www.wowotech.net/content/uploadfile/201511/10fb1447331995.png)

![img](https://upload-images.jianshu.io/upload_images/2828107-ccacf8853af203c6.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/553/format/webp)

### 一个可回收页面的生命周期

+ 文件页

    `Free -> INACTIVE -> [ACTIVE] <-> INACTIVE -> Reclaimable -> Free`

    在 Buddy System 中未被分配时，属于 `Free` 状态。当被分配时，首先被挂在 `INACTIVE` 链上。若被进程访问，就会变成 `ACTIVE`。当一段时间没有被访问时，又会被转成 `INACTIVE`，并在 `INACTIVE` 链上等待被回收。若被回收就会回到 Buddy System 变为 `Free`。

+ 匿名页

    `Free -> ACTIVE <-> [INACTIVE] -> Reclaimable -> Free`

    匿名页通过 `page fault` 被分配以后，在 `ACTIVE` 链表上，经过 deactive 变为 `INACTIVE`，最后被回收到 Buddy System 中。

对于匿名页和文件页，刚被分配后所设置的状态，可以得出：系统总是想尽快老化文件页面。在系统的眼中，文件页的换出成本要低于匿名页。

### Swappiness

Linux 内存回收可以回收文件页和匿名页。而 Swappiness 越大，越倾向于回收匿名页，积极地把内存中的数据搬运到 `swap` 分区中；反之，更倾向于回收文件页。

### 参考资料

https://www.jianshu.com/p/7ab51b8a6368
http://abcdxyzk.github.io/blog/2015/04/18/kernel-mm-reclaim2/